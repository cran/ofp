%\VignetteIndexEntry{ofp1_Enhanced_S3_Programming}
\documentclass {article}
\usepackage {maia2}
\SweaveOpts{keep.source=TRUE}
\SweaveOpts{prefix.string=tmp-ofp1}
\definecolor{rerr}{rgb}{0.5, 0.025, 0}
\DefineVerbatimEnvironment{Serror}{Verbatim}{xleftmargin=2em,formatcom=\color{rerr}}

\begin{document}

<<echo=false>>=
options(continue=" ")
#options(SweaveHooks=list(fig=function() par(mar=c(5.1, 4.1, 1.1, 2.1))))
library (ofp)
@

\mtitle {ofp}{0.6.0}{Enhanced S3 Programming\\(Draft)}

\mabstract {This vignette introduces the first part of the ofp package, a framework for enhanced S3 programming.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\msec {Introduction}

There are two major object oriented systems in R, S3 and S4. Arguably, S3 deviates from conventional object oriented programming, however is relatively simple, has an inherent functional flavour and is very flexible. In contrast, S4 is relatively complex, very structured and very verbose.

The first part of this package is designed to enhance S3 capabilities, firstly, giving it a more standard object oriented flavour, and secondly, emphasizing simplicity and readability.

The largest section of this vignette discusses enhanced primitives, which include:
\begin {itemize}
	\item Enhanced lists.
	\item Enhanced environments.
	\item Enhanced functions.
	\item Enhanced vectors.
\end {itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\msec {Simplified Constructors}

A typical design pattern for a constructor, is a function (roughly speaking), that:
\begin {enumerate}
	\item Creates an instance of the class (including creating an instance of any superclass, where often the superclass constructor is the first call within function).
	\item Extends the class attribute (for S3).
	\item Sets any further attributes.
	\item Returns the object.
\end {enumerate}

\noindent So a superclass/subclass example might be:
<<>>=
point = function (x=0, y=0)
	structure (list (x=x, y=y), class=c ("point", "list") )
@

<<>>=
circle = function (x=0, y=0, r=1)
{	obj = point (x, y)
	class (obj) = c ("circle", class (obj) )
	obj
}
@

<<>>=
colouredcircle = function (x=0, y=0, r=1,
	line.colour="black", fill.colour="white")
{	obj = circle (x, y, r)
	class (obj) = c ("colouredcircle", class (obj) )
	obj$line.colour = line.colour
	obj$fill.colour = fill.colour
	obj
}
@

\noindent Mostly that's fine. However, in the superclass constructor, explicitly naming each argument of the list is cumbersome. Secondly, the subclass constructors are way too long. Using the ofp package, we can instead write:
<<>>=
point = function (x=0, y=0) extend (LIST (x, y), "point")
@

<<>>=
circle = function (x=0, y=0, r=1) extend (point (x, y), "circle", r)
@

<<>>=
colouredcircle = function (x=0, y=0, r=1,
	line.colour="black", fill.colour="white")
	extend (circle (x, y, r), "colouredcircle", line.colour, fill.colour)
@

<<>>=
colouredcircle (fill="blue")
@

\noindent Alternatively (for the one of subclass constructors):
<<>>=
circle = function (x=0, y=0, r=1)
{	obj = extend (point (x, y), "circle")
	implant (obj, r)
}
@

\noindent We shall discuss LIST objects later. The import parts are the extend and implant functions, which serve to make our code succinct.

The extend function, is intended to take an object (as it's first argument), the name of the subclass (as it's second argument), and potentially further arguments representing attributes for the object. Then it returns the extended object.

The implant function is almost identical to the extend function, except that it doesn't take the name of a subclass as an argument, and doesn't adjust the class attribute.

One restriction, is that we can not call either extend or implant using dots. The following is not allowed:
<<eval=false>>=
extend (circle (x, y, r), "colouredcircle", ...)
@

\noindent One further word of warning. The view of the author, is that it's advisable to always extend the class attribute, by appending a value to it, rather than simply setting it to some scalar value.

Occasionally, R programs use calls such as \verb|inherits (obj, "something")|, which may fail to produce the expected result, if we simply do something like \verb|class (obj) = "circle"|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\msec {Object References}

There are many situations where we wish to create an object reference. The objref function allows us to do this (noting that environments, discussed later, provide a more efficient and flexible system). To create an object reference, we call objref with an object as it's single argument. The reference that is returned, it actually a function itself, which when evaluated (with no arguments) returns the object.

Let's say we want an object reference to a matrix.
<<>>=
m = objref (matrix (1:16, nrow=4) )
m
m ()
@

\noindent To create multiple references to the same object:
<<>>=
q = m
@

\noindent Extraction methods have been implemented, to simplify working with references to lists and vectors. These also provide the main process for modifying the object.
<<>>=
m [1, 1]
m [1, 1] = 0
m [1, 1]
@

\noindent Because it's a reference, dereferencing q, will yield our modified matrix:
<<>>=
q [1, 1]
@

\noindent Noting that the following are not equivalent.
<<eval=false>>=
m () [1, 1] = 1
m [1, 1] = 1
@

\noindent Note that the objref system may be changed in future versions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\msec {Enhanced Primitives}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection* {Enhanced Lists}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We touched on enhanced lists earlier, namely the LIST object. The main purpose of LIST objects is to remove the need to explicitly name each argument in the list. So the following:
<<>>=
x = 1
y = 2
obj = list (x=x, y=y, z=3)
obj
@

\noindent Can be simplified to (noting the LIST arguments):
<<>>=
x = 1
y = 2
obj = LIST (x, y, z=3)
obj
@

\noindent Note that the current version prevents creating enhanced lists with dots as an argument (unless we specify the call object, see the Rd file, which is slightly complex). This feature is may be changed in future versions. So the following is not allowed:
<<eval=false>>=
f = function (...) LIST (...)
f (x, y)
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection* {Enhanced Environments}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Extending environments is relatively simple, however it doesn't seem to be common practice. One reason we might want to extend an environment is to write our own print method.
<<>>=
e = extend (new.env (), "myenv")
print.myenv = function (e) print ("a myenv object")
e
@

\noindent The ofp package, also provides ENVIRONMENT (enhanced environments) objects, that extend environments. These provide workarounds to some of the limitations of standard environments. Furthermore, ENVIRONMENT objects can be extended. A problem with using standard environments is that creating an environment required separate calls, for each assignment. Using ENVIRONMENT objects we can create environments in a similar way to lists. Presently, ENVIRONMENT objects, print themselves, by calling as.list, however it's not recursive (so nested environments print the usual way).
<<>>=
e = ENVIRONMENT (x=1, y=2, z=3)
e
@

\noindent We can compare two ENVIRONMENT objects for equality:
<<>>=
e = f = ENVIRONMENT ()
g = ENVIRONMENT ()
e == f
e == g
@

\noindent Extending ENVIRONMENT objects is trivial:
<<>>=
e = extend (ENVIRONMENT (), "myenv2")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection* {Enhanced Functions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Enhanced functions, are created with the FUNCTION function. This is discussed in the next vignette.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection* {Enhanced Vectors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The purpose of enhanced vectors is to support the use of vectors with attributes. R already allows vectors to have attributes, however the process is not as simple as accessing the elements of a list. So we provide enhanced vectors, using list-like syntax. There are currently five kinds of enhanced vectors, TEXT, REAL, COMPLEX, INTEGER and LOGICAL, where TEXT extends character vectors, and REAL extends numeric vectors. To create an enhanced vector, with some attributes.
<<>>=
x = INTEGER (1:10, someattribute=TRUE, someotherattribute=FALSE)
x
x$someattribute = FALSE
x$someattribute
@

\noindent Alternatively, we can create a vector by omitting the first argument and providing a dimension value. Noting that there are currently some problems using this approach to create matrices.
<<>>=
INTEGER (dimension=2)
@

\noindent The process to create the other vectors is the same.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\msec {Simplified Methods}

In the earlier section on constructors, we created a point class, now let's create a method, an intuitive one...
<<>>=
#a possible print method
print.point = function (p, ...) cat ("x:", p$x, "\ny:", p$y, "\n")
@

<<>>=
p = point (0, 0)
p
@

\noindent At face value, if works fine. However, let's try and make a package...
\begin{Schunk}
\begin{Sinput}
> R CMD check My1stRPackage
\end{Sinput}
\begin{Serror}
* checking S3 generic/method consistency ... WARNING
print:
  function(x, ...)
print.point:
  function(p)
\end{Serror}
\end{Schunk}

\noindent After a few changes...
<<>>=
#another possible print method
print.point = function (x, ...) cat ("x:", x$x, "\ny:", x$y, "\n")
@

\noindent Now, R Check is content, however I don't want to call my object x, I want to call p. So the ofp package implements mask functions, that ``mask'' a subset of the standard generics. In principle, we should still include the dots argument, however otherwise we can use what ever arguments we want. Currently (these may change) the ofp package masks print, summary, format, plot, lines and points. Now, if we load ofp, we can use p instead of x, and R Check is still content.

One can mask other generics, say mean, using a declaration such as:
<<>>=
mean = function (...) base::mean (...)
@

\noindent This will create some overhead, however using method despatch at all, creates overhead. R check will think that mean is a regular function, rather than a generic. Noting that calling mean.myobject will still call the mean generic.

\end{document}

